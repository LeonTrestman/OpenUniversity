     Solutions for time and space complexity questions from finals of intro to cs and java openU
     Written by Leon Trestman 
    
///////////////////////////////////////////////////////////////////////////
            //2016 2a 83
            //Variation of binary search
    public static boolean findX(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left != right) {

            int mid = (left + right) / 2;

            //check for edge cases ,and not getting out of bound
            if (mid - 1 < 0 && arr[mid] + arr[mid + 1] != target)
                return false;

            if (mid + 1 > arr.length - 1 && arr[mid] + arr[mid - 1] != target)
                return false;

            //check for sum of two nearby without going out of bounds.
            if (mid - 1 > 0 && arr[mid] + arr[mid - 1] == target) {
                return true;
            }
            if (mid + 1 < arr.length && arr[mid] + arr[mid + 1] == target) {
                return true;
            }

            if (arr[mid] + arr[mid - 1] > target) {
                right = mid - 1;

            } else {
                left = mid + 1;
            }

        }
        return false;
    }
///////////////////////////////////////////////////////////////////////////
              //2017b 85 4a
              
public static void printClosest(int[]a , int[]b ,int x){

    int left = 0;
    int right = b.length - 1;
    int sum = a[left] + b[right];
    int closest = Math.abs(x - sum);
    int num1 = 0;
    int num2 = 0;

    while ( left < a.length-1 && right > -1){
        sum = a[left] + b[right];

        if(Math.abs(x-sum) < closest){
            closest =Math.abs(sum-x);
            num1 = a[left];
            num2 = b[right];
        }

        if (sum < x){
            left++;
        }else{
            right--;
        }
    }
    System.out.println(num1 + " and " + num2);
}
///////////////////////////////////////////////////////////////////////////
